<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[1-4-Render函数]]></title>
    <url>%2F2018%2F06%2F25%2F1-4-Render%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[renderVue 的 _render 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node。它的定义在 src/core/instance/render.js 文件中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options // reset _rendered flag on slots for duplicate slot check if (process.env.NODE_ENV !== 'production') &#123; for (const key in vm.$slots) &#123; // $flow-disable-line vm.$slots[key]._rendered = false &#125; &#125; if (_parentVnode) &#123; vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject &#125; // set parent vnode. this allows render functions to have access // to the data on the placeholder node. vm.$vnode = _parentVnode // render self let vnode try &#123; vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; handleError(e, vm, `render`) // return error render result, // or previous vnode to prevent render error causing blank component /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') &#123; if (vm.$options.renderError) &#123; try &#123; vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) &#125; catch (e) &#123; handleError(e, vm, `renderError`) vnode = vm._vnode &#125; &#125; else &#123; vnode = vm._vnode &#125; &#125; else &#123; vnode = vm._vnode &#125; &#125; // return empty vnode in case the render function errored out if (!(vnode instanceof VNode)) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; Array.isArray(vnode)) &#123; warn( 'Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm ) &#125; vnode = createEmptyVNode() &#125; // set parent vnode.parent = _parentVnode return vnode&#125; 这段代码最关键的是 render 方法的调用，我们在平时的开发工作中手写 render 方法的场景比较少，而写的比较多的是 template 模板，在之前的 mounted 方法的实现中，会把 template 编译成 render 方法，但这个编译过程是非常复杂的，我们不打算在这里展开讲，之后会专门花一个章节来分析 Vue 的编译过程。 在 Vue 的官方文档中介绍了 render 函数的第一个参数是 createElement，那么结合之前的例子：123&lt;div id="app"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 相当于我们编写如下 render 函数： 1234567render: function (createElement) &#123; return createElement('div', &#123; attrs: &#123; id: 'app' &#125;, &#125;, this.message)&#125; 再回到 _render 函数中的 render 方法的调用： 1vnode = render.call(vm._renderProxy, vm.$createElement) 可以看到，render 函数中的 createElement 方法就是 vm.$createElement 方法：1234567891011export function initRender (vm: Component) &#123; // ... // bind the createElement fn to this instance // so that we get proper render context inside it. // args order: tag, data, children, normalizationType, alwaysNormalize // internal version is used by render functions compiled from templates vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) // normalization is always applied for the public version, used in // user-written render functions. vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true)&#125; 实际上，vm.$createElement 方法定义是在执行 initRender 方法的时候，可以看到除了 vm.$createElement 方法，还有一个 vm._c 方法，它是被模板编译成的 render 函数使用，而 vm.$createElement 是用户手写 render 方法使用的， 这俩个方法支持的参数相同，并且内部都调用了 createElement 方法。 总结vm._render 最终是通过执行 createElement 方法并返回的是 vnode，它是一个虚拟 Node。Vue 2.0 相比 Vue 1.0 最大的升级就是利用了 Virtual DOM。因此在分析 createElement 的实现前，我们先了解一下 Virtual DOM 的概念。]]></content>
      <categories>
        <category>vue源码分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1.3-初始化数据中心]]></title>
    <url>%2F2018%2F06%2F19%2F1-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[初始化数据中心在init.js中，在初始化一堆东西的时候，有这么一行代码在上篇讲述的一堆初始化中会调用state.js中的initState方法，这篇文章会过一下state.js的大致流程 initState 在state.js中会发现导出一个函数，函数名为initState 123456789101112131415 export function initState(vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */ ) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 上面的代码 : 第一步会创建一个watch数组，这个是关于响应式部分，以后会讲到 第二步拿到在new Vue 时传入的对象 第三步判断当前是否存在props，存在的话则初始化props 第四步判断当前是否存在methods，存在的话则初始化methods 第五步判断当前是否存在data，存在的话则初始化对象（也就是数据），否则会创建一个空对象作为根数据，也就是你当前生命还是没生命这个data，Vue内部都会创建一个_data的私有对象，并且加入到观察者模式中去(其实这个_data和data是一模一样的，只不过_data是一个私有对象) 第六步判断computed，存在则初始化 第七步则判断watch，存在则初始化 initData 我们只需要关注如何初始化数据就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142 function initData(vm: Component) &#123; let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; // 忽略这个判断逻辑 if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) &#125; // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== 'production') &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method "$&#123;key&#125;" has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property "$&#123;key&#125;" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; // observe data observe(data, true /* asRootData */ )&#125; 在经过initState函数时会初始化数据，我们假设此时已经传入了数据，如下 1234567const vm = new Vue(&#123; data()&#123; return &#123; name:"灰太狼" &#125; &#125;&#125;) 第一步会拿到这个传入的data 第二步做一个判断，当前传入的data是一个函数还是一个对象，如果是函数的话会调用getData，将data和vm传入，这个函数会返回经过observer的对象 第三步将所有的data作为一个数组(此时keys=[name])，并且拿到methods和props，使用data的key循环进行判断，如果当前的props没有与key相同的key的话，则使用proxy代理到_data中，也就是说我们打印vm.name会得到&quot;灰太狼&quot;，我们打印vm._data也会得到灰太狼 第四步也是最后一步，把所有的data进行一个observer(观察者模式),这步也是响应式的重要的一步(后面会讲解) 下篇预告render函数]]></content>
      <categories>
        <category>vue源码分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1.2-NewVue]]></title>
    <url>%2F2018%2F06%2F13%2F1-2-NewVue%2F</url>
    <content type="text"><![CDATA[Vue在哪里在这里会告诉你Vue的来源，是什么样子的首先进入源码目录下的/src/core目录，里面有一个index.js的文件 1234567891011121314151617181920212223242526272829import Vue from './instance/index'import &#123; initGlobalAPI &#125; from './global-api/index'import &#123; isServerRendering &#125; from 'core/util/env'import &#123; FunctionalRenderContext &#125; from 'core/vdom/create-functional-component'// 向Vue绑定静态方法，比如Vue.set. Vue.delete Vue.useinitGlobalAPI(Vue)// 这几行代码不用关注，这是只有在服务端渲染才会使用到Object.defineProperty(Vue.prototype, '$isServer', &#123; get: isServerRendering&#125;)Object.defineProperty(Vue.prototype, '$ssrContext', &#123; get () &#123; /* istanbul ignore next */ return this.$vnode &amp;&amp; this.$vnode.ssrContext &#125;&#125;)// expose FunctionalRenderContext for ssr runtime helper installationObject.defineProperty(Vue, 'FunctionalRenderContext', &#123; value: FunctionalRenderContext&#125;)Vue.version = '__VERSION__'export default Vue 我们会发现在最下方有一行代码 export default Vue，这个被导出的Vue在最上方的import Vue from &#39;./instance/index&#39;中导入进来，继续进入到/instance/index.js，在这个文件中我们会看到Vue是如何定义的 12345678910111213141516171819202122232425import &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'import &#123; warn &#125; from '../util/index'function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; // 这里会判断你在使用Vue的时候是否用new的方式，否则会抛出一个警告 !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;// 每一个Mixin实际上是向Vue中混入一些定义好的方法initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 在上面的代码中，我们可以看到定义了一个Vue的类，在这个类中（除去判断逻辑，说明在注释中有）我们当前的Vue的实例（this），调用了init的方法，将new Vue时传入的参数传递过去，这个_init方法在./init.js中被定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Vue.prototype._init = function (options ?: Object) &#123; const vm: Component = this // a uid vm._uid = uid++ let startTag, endTag /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; startTag = `vue-perf-start:$&#123;vm._uid&#125;` endTag = `vue-perf-end:$&#123;vm._uid&#125;` mark(startTag) &#125; // a flag to avoid this being observed vm._isVue = true // merge options // 混入options会在后面章节中重点说 if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) &#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) &#125; // 经过上面的逻辑后，vm.$options就等于init时传入的options， // vm.$options.el = new Vue时传入的el // vm.$options.data = new Vue时传入的data /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') &#123; initProxy(vm) &#125; else &#123; vm._renderProxy = vm &#125; // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue $&#123;vm._name&#125; init`, startTag, endTag) &#125; // 在这里挂载传入的el if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125;&#125; 上面的代码其实做了这么几件事情 合并配置 初始化生命周期 初始化事件中心 初始化渲染 初始化data,props. computed等 到此New Vue 已经完成了Vue把不同功能的函数分开操作，这种逻辑值得我们学习 如果你不会或者不了解Object.defineProperty()这个方法的话建议去这里看一下简单的介绍和使用，不然在接下来的源码分析过程中会很吃力，Vue内部的响应式的基本原理就是基于这个方法 下一篇会进入initState(vm)这个函数内部查看是如何将在data内部定义的参数可以在methods使用this的方式查看使用]]></content>
      <categories>
        <category>vue源码分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0.1-准备工作]]></title>
    <url>%2F2018%2F06%2F12%2F0-1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[准备工作及序言&nbsp;&nbsp;&nbsp;&nbsp;序什么样的人适合阅读源码？我希望你有最基本javascript的基础，比如闭包，函数柯里化…，使用vue做过项目 vuejs的版本？目前版本为在github上最新的代码，V2.5.17 多久更新一次？每周都会更新，打算将这个源码解析系列当作长期项目来维护 会不会逐行分析代码？不会，这么做会浪费大量时间，不重要的函数会选择性跳过，但大部分代码还是会说到 说明在开始阅读vue源码之前需要做一点准备工作，由于本人的技术能力和精力有限,对编译不太懂，这次的vue源码解析不会涉及到虚拟dom,大致会解析以下核心的几个部分，数据驱动,render,组件化,生命周期，异步组件,vue Router，Vuex,和相应式原理，之所以把响应式原理放到最后是因为会深入解析. 在github下载vueJs的源代码 点击此处跳转到github 由于vue基于flow语法，需要提前了解如何使用Flow,Flow 是 facebook 出品的 JavaScript 静态类型检查工具。Vue.js 的源码利用了 Flow 做了静态类型检查，所以了解 Flow 有助于我们阅读源码。:Flow就使用层面来说还是很简单的，即使不会但是了解过静态语言比如JAVA的话，看起来还是可以看懂的.]]></content>
      <categories>
        <category>vue源码分析</category>
      </categories>
      <tags>
        <tag>Vue.js源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.1-从入口开始]]></title>
    <url>%2F2018%2F06%2F12%2F1.1-%E4%BB%8E%E5%85%A5%E5%8F%A3%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[Vue源码目录设计在把github上的代码clone之后，会发现Vue.js的源码工程非常庞大，但是不用担心，我们只需要分析src目录下的代码Vue.js 的源码都在 src 目录下，其目录结构如下1234567src ├── compiler # 编译相关 ├── core # 核心代码 (:我们会重点分析这里面的代码 ├── platforms # 不同平台的服务支持代码 ├── server # 服务端渲染 ├── sfc # .vue 文件解析 └── shared # 共享代码 compilercompiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能 corecore 目录包含了 Vue.js 的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等这是vue.js的核心代码，也是之后重点分析的地方 platform由于Vue.js是跨平台框架，可以编译在web端运行，也可以在Native客户端上运行(配合weex)，platform目录分别打包成运行在web和weex上的vue代码，不同的平台的入口编译不同的Vue.js serverVue.js2.0支持服务端渲染，所有服务端渲染逻辑会在这个目录下．有些代码是运行在Node.js上，不要和在web端的代码混为一谈 sfc这个目录下的代码会把.vue单文件解析成一个javaScript对象 shared一些辅助的方法，Vue.js(Web端 or 服务端)中的工具方法会定义在这个文件夹内，这些方法会被Vue.js其他的模块共享 Vue.js把模块拆分比较清晰，使用层面也是比较方便维护和使用的，通过模块化的方式让这些模块互相引用，最终通过打包工具进行打包成一个js文件，下面我们会分析一下Vue.js是如何构建的 Vue源码构建Vue.js 源码是基于 Rollup 构建的，它的构建相关配置都在 scripts 目录下。 什么是Rollup?Rollup是和webpack类似的构建工具，它会把冗余代码都剔除出去，打出来的包更轻量一点，比较适合javaScript库的编译 Vue.js也是在npm上面发布的，所以根目录有一个package.json文件，关于这个json文件如果不会的话可以先去弥补一下相关知识 构建过程在package.json中会看到script这个脚本，在内部有大量的命令，我们不需要关注其他的命令，只需要看到这三条即可123"build": "node scripts/build.js", // 运行在web端的Vue.js"build:ssr": "npm run build -- web-runtime-cjs,web-server-renderer",// 运行在服务端中的Vue.js"build:weex": "npm run build -- weex", // 运行在weex中的Vue.js 在运行 npm run build时，实际上运行的是 node scripts/build.js，下面两行代码同理 如何构建在执行node scripts/build.js脚本时，node会寻找scripts目录下的build.js文件，我会把构建流程的代码+注释放到这里，如果看不懂的话没关系，这不属于Vue核心代码，只是告诉大家Vue.js是如何构建的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106const fs = require('fs')const path = require('path')const zlib = require('zlib')const rollup = require('rollup')const uglify = require('uglify-js')if (!fs.existsSync('dist')) &#123; fs.mkdirSync('dist')&#125;// 会返回一个数组，数组中则是不同构建的版本的配置，比如是否压缩源码，是否启用Babel转编译let builds = require('./config').getAllBuilds()console.log(builds)// 在这里进行一层过滤，区分是打包ssr环境还是打包weex的代码if (process.argv[2]) &#123; const filters = process.argv[2].split(',') builds = builds.filter(b =&gt; &#123; return filters.some(f =&gt; b.output.file.indexOf(f) &gt; -1 || b._name.indexOf(f) &gt; -1) &#125;)&#125; else &#123; // filter out weex builds by default builds = builds.filter(b =&gt; &#123; return b.output.file.indexOf('weex') === -1 &#125;)&#125;// 开始构建代码build(builds)function build(builds) &#123; let built = 0 const total = builds.length // 递归操作把构建的参数放到构建函数入口中 const next = () =&gt; &#123; buildEntry(builds[built]).then(() =&gt; &#123; built++ if (built &lt; total) &#123; next() &#125; &#125;).catch(logError) &#125; next()&#125;// 执行打包的入口，传入配置项function buildEntry(config) &#123; const output = config.output const &#123; file, banner &#125; = output const isProd = /min\.js$/.test(file) // 这个地方 把这个配置项交给rollup去编译，编译后产生一个bundle，这个bundle在调用generate方法，把配置项传入，得到最后的Code，也就是编译后的代码，最终执行write方法，把Code写到js文件中 return rollup.rollup(config) .then(bundle =&gt; bundle.generate(output)) .then((&#123; code &#125;) =&gt; &#123; if (isProd) &#123; var minified = (banner ? banner + '\n' : '') + uglify.minify(code, &#123; output: &#123; ascii_only: true &#125;, compress: &#123; pure_funcs: ['makeMap'] &#125; &#125;).code return write(file, minified, true) &#125; else &#123; return write(file, code) &#125; &#125;)&#125;// 最终将代码写入文件function write(dest, code, zip) &#123; return new Promise((resolve, reject) =&gt; &#123; function report(extra) &#123; console.log(blue(path.relative(process.cwd(), dest)) + ' ' + getSize(code) + (extra || '')) resolve() &#125; fs.writeFile(dest, code, err =&gt; &#123; if (err) return reject(err) if (zip) &#123; zlib.gzip(code, (err, zipped) =&gt; &#123; if (err) return reject(err) report(' (gzipped: ' + getSize(zipped) + ')') &#125;) &#125; else &#123; report() &#125; &#125;) &#125;)&#125;function getSize(code) &#123; return (code.length / 1024).toFixed(2) + 'kb'&#125;function logError(e) &#123; console.log(e)&#125;function blue(str) &#123; return '\x1b[1m\x1b[34m' + str + '\x1b[39m\x1b[22m'&#125; 上面的代码的执行顺序就是 第一步首先调用config文件中的getAllBuilds函数，这个函数会返回一个数组，数组内是对象，对象包含构建不同版本的Vue.js的配置项第二步调用build函数，将getAllBuilds这个函数的返回值传入进去第三步在build函数内递归调用buildEntry函数，将配置项传入，注意:( 这时候配置项是单个的对象，不是数组了 )第四步在buildEntry中会调用rollup.rollup方法，这个方法会根据配置项去编译，编译后产生一个bundle，这个bundle在调用generate方法，把配置项传入，得到最后的Code，也就是编译后的代码，最终执行write方法，把Code写到js文件中第四步如果看不懂的话，下面这串代码可以看懂了12345678910111213141516171819rollup.rollup(config).then(function (bundle) &#123; return bundle.generate(output);&#125;).then(function (_ref) &#123; var code = _ref.code; if (isProd) &#123; var minified = (banner ? banner + '\n' : '') + uglify.minify(code, &#123; output: &#123; ascii_only: true &#125;, compress: &#123; pure_funcs: ['makeMap'] &#125; &#125;).code; return write(file, minified, true); &#125; else &#123; return write(file, code); &#125;&#125;); 这块属于构建工具的过程，就不继续详述了，如果想了解的话可以查看官方文档或者留言，我会抽时间出一个博客简单介绍一下 下一篇会介绍Vue到底是什么，是怎么初始化的.]]></content>
      <categories>
        <category>vue源码分析</category>
      </categories>
  </entry>
</search>
