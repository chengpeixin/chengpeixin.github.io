<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[0.1-准备工作]]></title>
    <url>%2F2018%2F06%2F12%2F0-1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[准备工作及序言&nbsp;&nbsp;&nbsp;&nbsp;序什么样的人适合阅读源码？我希望你有最基本javascript的基础，比如闭包，函数柯里化…，使用vue做过项目 vuejs的版本？目前版本为在github上最新的代码，V2.5.17 多久更新一次？每周都会更新，打算将这个源码解析系列当作长期项目来维护 会不会逐行分析代码？不会，这么做会浪费大量时间，不重要的函数会选择性跳过，但大部分代码还是会说到 说明在开始阅读vue源码之前需要做一点准备工作，由于本人的技术能力和精力有限,对编译不太懂，这次的vue源码解析不会涉及到虚拟dom,大致会解析以下核心的几个部分，数据驱动,render,组件化,生命周期，异步组件,vue Router，Vuex,和相应式原理，之所以把响应式原理放到最后是因为会深入解析. 在github下载vueJs的源代码 点击此处跳转到github 由于vue基于flow语法，需要提前了解如何使用Flow,Flow 是 facebook 出品的 JavaScript 静态类型检查工具。Vue.js 的源码利用了 Flow 做了静态类型检查，所以了解 Flow 有助于我们阅读源码。:Flow就使用层面来说还是很简单的，即使不会但是了解过静态语言比如JAVA的话，看起来还是可以看懂的.]]></content>
      <categories>
        <category>vue源码分析</category>
      </categories>
      <tags>
        <tag>Vue.js源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.1-从入口开始]]></title>
    <url>%2F2018%2F06%2F12%2F1.1-%E4%BB%8E%E5%85%A5%E5%8F%A3%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[Vue源码目录设计在把github上的代码clone之后，会发现Vue.js的源码工程非常庞大，但是不用担心，我们只需要分析src目录下的代码Vue.js 的源码都在 src 目录下，其目录结构如下1234567src ├── compiler # 编译相关 ├── core # 核心代码 (:我们会重点分析这里面的代码 ├── platforms # 不同平台的服务支持代码 ├── server # 服务端渲染 ├── sfc # .vue 文件解析 └── shared # 共享代码 compilercompiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能 corecore 目录包含了 Vue.js 的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等这是vue.js的核心代码，也是之后重点分析的地方 platform由于Vue.js是跨平台框架，可以编译在web端运行，也可以在Native客户端上运行(配合weex)，platform目录分别打包成运行在web和weex上的vue代码，不同的平台的入口编译不同的Vue.js serverVue.js2.0支持服务端渲染，所有服务端渲染逻辑会在这个目录下．有些代码是运行在Node.js上，不要和在web端的代码混为一谈 sfc这个目录下的代码会把.vue单文件解析成一个javaScript对象 shared一些辅助的方法，Vue.js(Web端 or 服务端)中的工具方法会定义在这个文件夹内，这些方法会被Vue.js其他的模块共享 Vue.js把模块拆分比较清晰，使用层面也是比较方便维护和使用的，通过模块化的方式让这些模块互相引用，最终通过打包工具进行打包成一个js文件，下面我们会分析一下Vue.js是如何构建的 Vue源码构建Vue.js 源码是基于 Rollup 构建的，它的构建相关配置都在 scripts 目录下。 什么是Rollup?Rollup是和webpack类似的构建工具，它会把冗余代码都剔除出去，打出来的包更轻量一点，比较适合javaScript库的编译 Vue.js也是在npm上面发布的，所以根目录有一个package.json文件，关于这个json文件如果不会的话可以先去弥补一下相关知识 构建过程在package.json中会看到script这个脚本，在内部有大量的命令，我们不需要关注其他的命令，只需要看到这三条即可123"build": "node scripts/build.js", // 运行在web端的Vue.js"build:ssr": "npm run build -- web-runtime-cjs,web-server-renderer",// 运行在服务端中的Vue.js"build:weex": "npm run build -- weex", // 运行在weex中的Vue.js 在运行 npm run build时，实际上运行的是 node scripts/build.js，下面两行代码同理 如何构建在执行node scripts/build.js脚本时，node会寻找scripts目录下的build.js文件，我会把构建流程的代码+注释放到这里，如果看不懂的话没关系，这不属于Vue核心代码，只是告诉大家Vue.js是如何构建的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106const fs = require('fs')const path = require('path')const zlib = require('zlib')const rollup = require('rollup')const uglify = require('uglify-js')if (!fs.existsSync('dist')) &#123; fs.mkdirSync('dist')&#125;// 会返回一个数组，数组中则是不同构建的版本的配置，比如是否压缩源码，是否启用Babel转编译let builds = require('./config').getAllBuilds()console.log(builds)// 在这里进行一层过滤，区分是打包ssr环境还是打包weex的代码if (process.argv[2]) &#123; const filters = process.argv[2].split(',') builds = builds.filter(b =&gt; &#123; return filters.some(f =&gt; b.output.file.indexOf(f) &gt; -1 || b._name.indexOf(f) &gt; -1) &#125;)&#125; else &#123; // filter out weex builds by default builds = builds.filter(b =&gt; &#123; return b.output.file.indexOf('weex') === -1 &#125;)&#125;// 开始构建代码build(builds)function build(builds) &#123; let built = 0 const total = builds.length // 递归操作把构建的参数放到构建函数入口中 const next = () =&gt; &#123; buildEntry(builds[built]).then(() =&gt; &#123; built++ if (built &lt; total) &#123; next() &#125; &#125;).catch(logError) &#125; next()&#125;// 执行打包的入口，传入配置项function buildEntry(config) &#123; const output = config.output const &#123; file, banner &#125; = output const isProd = /min\.js$/.test(file) // 这个地方 把这个配置项交给rollup去编译，编译后产生一个bundle，这个bundle在调用generate方法，把配置项传入，得到最后的Code，也就是编译后的代码，最终执行write方法，把Code写到js文件中 return rollup.rollup(config) .then(bundle =&gt; bundle.generate(output)) .then((&#123; code &#125;) =&gt; &#123; if (isProd) &#123; var minified = (banner ? banner + '\n' : '') + uglify.minify(code, &#123; output: &#123; ascii_only: true &#125;, compress: &#123; pure_funcs: ['makeMap'] &#125; &#125;).code return write(file, minified, true) &#125; else &#123; return write(file, code) &#125; &#125;)&#125;// 最终将代码写入文件function write(dest, code, zip) &#123; return new Promise((resolve, reject) =&gt; &#123; function report(extra) &#123; console.log(blue(path.relative(process.cwd(), dest)) + ' ' + getSize(code) + (extra || '')) resolve() &#125; fs.writeFile(dest, code, err =&gt; &#123; if (err) return reject(err) if (zip) &#123; zlib.gzip(code, (err, zipped) =&gt; &#123; if (err) return reject(err) report(' (gzipped: ' + getSize(zipped) + ')') &#125;) &#125; else &#123; report() &#125; &#125;) &#125;)&#125;function getSize(code) &#123; return (code.length / 1024).toFixed(2) + 'kb'&#125;function logError(e) &#123; console.log(e)&#125;function blue(str) &#123; return '\x1b[1m\x1b[34m' + str + '\x1b[39m\x1b[22m'&#125; 上面的代码的执行顺序就是 第一步首先调用config文件中的getAllBuilds函数，这个函数会返回一个数组，数组内是对象，对象包含构建不同版本的Vue.js的配置项第二步调用build函数，将getAllBuilds这个函数的返回值传入进去第三步在build函数内递归调用buildEntry函数，将配置项传入，注意:( 这时候配置项是单个的对象，不是数组了 )第四步在buildEntry中会调用rollup.rollup方法，这个方法会根据配置项去编译，编译后产生一个bundle，这个bundle在调用generate方法，把配置项传入，得到最后的Code，也就是编译后的代码，最终执行write方法，把Code写到js文件中第四步如果看不懂的话，下面这串代码可以看懂了12345678910111213141516171819rollup.rollup(config).then(function (bundle) &#123; return bundle.generate(output);&#125;).then(function (_ref) &#123; var code = _ref.code; if (isProd) &#123; var minified = (banner ? banner + '\n' : '') + uglify.minify(code, &#123; output: &#123; ascii_only: true &#125;, compress: &#123; pure_funcs: ['makeMap'] &#125; &#125;).code; return write(file, minified, true); &#125; else &#123; return write(file, code); &#125;&#125;); 这块属于构建工具的过程，就不继续详述了，如果想了解的话可以查看官方文档或者留言，我会抽时间出一个博客简单介绍一下 下一篇会介绍Vue到底是什么，是怎么初始化的.]]></content>
      <categories>
        <category>vue源码分析</category>
      </categories>
  </entry>
</search>
