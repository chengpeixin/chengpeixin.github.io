<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[1.2-NewVue]]></title>
    <url>%2F2018%2F06%2F13%2F1-2-NewVue%2F</url>
    <content type="text"><![CDATA[Vue在哪里在这里会告诉你Vue的来源，是什么样子的首先进入源码目录下的/src/core目录，里面有一个index.js的文件 1234567891011121314151617181920212223242526272829import Vue from './instance/index'import &#123; initGlobalAPI &#125; from './global-api/index'import &#123; isServerRendering &#125; from 'core/util/env'import &#123; FunctionalRenderContext &#125; from 'core/vdom/create-functional-component'// 向Vue绑定静态方法，比如Vue.set. Vue.delete Vue.useinitGlobalAPI(Vue)// 这几行代码不用关注，这是只有在服务端渲染才会使用到Object.defineProperty(Vue.prototype, '$isServer', &#123; get: isServerRendering&#125;)Object.defineProperty(Vue.prototype, '$ssrContext', &#123; get () &#123; /* istanbul ignore next */ return this.$vnode &amp;&amp; this.$vnode.ssrContext &#125;&#125;)// expose FunctionalRenderContext for ssr runtime helper installationObject.defineProperty(Vue, 'FunctionalRenderContext', &#123; value: FunctionalRenderContext&#125;)Vue.version = '__VERSION__'export default Vue 我们会发现在最下方有一行代码 export default Vue，这个被导出的Vue在最上方的import Vue from &#39;./instance/index&#39;中导入进来，继续进入到/instance/index.js，在这个文件中我们会看到Vue是如何定义的 12345678910111213141516171819202122232425import &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'import &#123; warn &#125; from '../util/index'function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; // 这里会判断你在使用Vue的时候是否用new的方式，否则会抛出一个警告 !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;// 每一个Mixin实际上是向Vue中混入一些定义好的方法initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 在上面的代码中，我们可以看到定义了一个Vue的类，在这个类中（除去判断逻辑，说明在注释中有）我们当前的Vue的实例（this），调用了init的方法，将new Vue时传入的参数传递过去，这个_init方法在./init.js中被定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Vue.prototype._init = function (options ?: Object) &#123; const vm: Component = this // a uid vm._uid = uid++ let startTag, endTag /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; startTag = `vue-perf-start:$&#123;vm._uid&#125;` endTag = `vue-perf-end:$&#123;vm._uid&#125;` mark(startTag) &#125; // a flag to avoid this being observed vm._isVue = true // merge options // 混入options会在后面章节中重点说 if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) &#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) &#125; // 经过上面的逻辑后，vm.$options就等于init时传入的options， // vm.$options.el = new Vue时传入的el // vm.$options.data = new Vue时传入的data /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') &#123; initProxy(vm) &#125; else &#123; vm._renderProxy = vm &#125; // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue $&#123;vm._name&#125; init`, startTag, endTag) &#125; // 在这里挂载传入的el if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125;&#125; 上面的代码其实做了这么几件事情 合并配置 初始化生命周期 初始化事件中心 初始化渲染 初始化data,props. computed等 到此New Vue 已经完成了Vue把不同功能的函数分开操作，这种逻辑值得我们学习 如果你不会或者不了解Object.defineProperty()这个方法的话建议去这里看一下简单的介绍和使用，不然在接下来的源码分析过程中会很吃力，Vue内部的响应式的基本原理就是基于这个方法 下一篇会进入initState(vm)这个函数内部查看是如何将在data内部定义的参数可以在methods使用this的方式查看使用]]></content>
      <categories>
        <category>vue源码分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0.1-准备工作]]></title>
    <url>%2F2018%2F06%2F12%2F0-1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[准备工作及序言&nbsp;&nbsp;&nbsp;&nbsp;序什么样的人适合阅读源码？我希望你有最基本javascript的基础，比如闭包，函数柯里化…，使用vue做过项目 vuejs的版本？目前版本为在github上最新的代码，V2.5.17 多久更新一次？每周都会更新，打算将这个源码解析系列当作长期项目来维护 会不会逐行分析代码？不会，这么做会浪费大量时间，不重要的函数会选择性跳过，但大部分代码还是会说到 说明在开始阅读vue源码之前需要做一点准备工作，由于本人的技术能力和精力有限,对编译不太懂，这次的vue源码解析不会涉及到虚拟dom,大致会解析以下核心的几个部分，数据驱动,render,组件化,生命周期，异步组件,vue Router，Vuex,和相应式原理，之所以把响应式原理放到最后是因为会深入解析. 在github下载vueJs的源代码 点击此处跳转到github 由于vue基于flow语法，需要提前了解如何使用Flow,Flow 是 facebook 出品的 JavaScript 静态类型检查工具。Vue.js 的源码利用了 Flow 做了静态类型检查，所以了解 Flow 有助于我们阅读源码。:Flow就使用层面来说还是很简单的，即使不会但是了解过静态语言比如JAVA的话，看起来还是可以看懂的.]]></content>
      <categories>
        <category>vue源码分析</category>
      </categories>
      <tags>
        <tag>Vue.js源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.1-从入口开始]]></title>
    <url>%2F2018%2F06%2F12%2F1.1-%E4%BB%8E%E5%85%A5%E5%8F%A3%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[Vue源码目录设计在把github上的代码clone之后，会发现Vue.js的源码工程非常庞大，但是不用担心，我们只需要分析src目录下的代码Vue.js 的源码都在 src 目录下，其目录结构如下1234567src ├── compiler # 编译相关 ├── core # 核心代码 (:我们会重点分析这里面的代码 ├── platforms # 不同平台的服务支持代码 ├── server # 服务端渲染 ├── sfc # .vue 文件解析 └── shared # 共享代码 compilercompiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能 corecore 目录包含了 Vue.js 的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等这是vue.js的核心代码，也是之后重点分析的地方 platform由于Vue.js是跨平台框架，可以编译在web端运行，也可以在Native客户端上运行(配合weex)，platform目录分别打包成运行在web和weex上的vue代码，不同的平台的入口编译不同的Vue.js serverVue.js2.0支持服务端渲染，所有服务端渲染逻辑会在这个目录下．有些代码是运行在Node.js上，不要和在web端的代码混为一谈 sfc这个目录下的代码会把.vue单文件解析成一个javaScript对象 shared一些辅助的方法，Vue.js(Web端 or 服务端)中的工具方法会定义在这个文件夹内，这些方法会被Vue.js其他的模块共享 Vue.js把模块拆分比较清晰，使用层面也是比较方便维护和使用的，通过模块化的方式让这些模块互相引用，最终通过打包工具进行打包成一个js文件，下面我们会分析一下Vue.js是如何构建的 Vue源码构建Vue.js 源码是基于 Rollup 构建的，它的构建相关配置都在 scripts 目录下。 什么是Rollup?Rollup是和webpack类似的构建工具，它会把冗余代码都剔除出去，打出来的包更轻量一点，比较适合javaScript库的编译 Vue.js也是在npm上面发布的，所以根目录有一个package.json文件，关于这个json文件如果不会的话可以先去弥补一下相关知识 构建过程在package.json中会看到script这个脚本，在内部有大量的命令，我们不需要关注其他的命令，只需要看到这三条即可123"build": "node scripts/build.js", // 运行在web端的Vue.js"build:ssr": "npm run build -- web-runtime-cjs,web-server-renderer",// 运行在服务端中的Vue.js"build:weex": "npm run build -- weex", // 运行在weex中的Vue.js 在运行 npm run build时，实际上运行的是 node scripts/build.js，下面两行代码同理 如何构建在执行node scripts/build.js脚本时，node会寻找scripts目录下的build.js文件，我会把构建流程的代码+注释放到这里，如果看不懂的话没关系，这不属于Vue核心代码，只是告诉大家Vue.js是如何构建的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106const fs = require('fs')const path = require('path')const zlib = require('zlib')const rollup = require('rollup')const uglify = require('uglify-js')if (!fs.existsSync('dist')) &#123; fs.mkdirSync('dist')&#125;// 会返回一个数组，数组中则是不同构建的版本的配置，比如是否压缩源码，是否启用Babel转编译let builds = require('./config').getAllBuilds()console.log(builds)// 在这里进行一层过滤，区分是打包ssr环境还是打包weex的代码if (process.argv[2]) &#123; const filters = process.argv[2].split(',') builds = builds.filter(b =&gt; &#123; return filters.some(f =&gt; b.output.file.indexOf(f) &gt; -1 || b._name.indexOf(f) &gt; -1) &#125;)&#125; else &#123; // filter out weex builds by default builds = builds.filter(b =&gt; &#123; return b.output.file.indexOf('weex') === -1 &#125;)&#125;// 开始构建代码build(builds)function build(builds) &#123; let built = 0 const total = builds.length // 递归操作把构建的参数放到构建函数入口中 const next = () =&gt; &#123; buildEntry(builds[built]).then(() =&gt; &#123; built++ if (built &lt; total) &#123; next() &#125; &#125;).catch(logError) &#125; next()&#125;// 执行打包的入口，传入配置项function buildEntry(config) &#123; const output = config.output const &#123; file, banner &#125; = output const isProd = /min\.js$/.test(file) // 这个地方 把这个配置项交给rollup去编译，编译后产生一个bundle，这个bundle在调用generate方法，把配置项传入，得到最后的Code，也就是编译后的代码，最终执行write方法，把Code写到js文件中 return rollup.rollup(config) .then(bundle =&gt; bundle.generate(output)) .then((&#123; code &#125;) =&gt; &#123; if (isProd) &#123; var minified = (banner ? banner + '\n' : '') + uglify.minify(code, &#123; output: &#123; ascii_only: true &#125;, compress: &#123; pure_funcs: ['makeMap'] &#125; &#125;).code return write(file, minified, true) &#125; else &#123; return write(file, code) &#125; &#125;)&#125;// 最终将代码写入文件function write(dest, code, zip) &#123; return new Promise((resolve, reject) =&gt; &#123; function report(extra) &#123; console.log(blue(path.relative(process.cwd(), dest)) + ' ' + getSize(code) + (extra || '')) resolve() &#125; fs.writeFile(dest, code, err =&gt; &#123; if (err) return reject(err) if (zip) &#123; zlib.gzip(code, (err, zipped) =&gt; &#123; if (err) return reject(err) report(' (gzipped: ' + getSize(zipped) + ')') &#125;) &#125; else &#123; report() &#125; &#125;) &#125;)&#125;function getSize(code) &#123; return (code.length / 1024).toFixed(2) + 'kb'&#125;function logError(e) &#123; console.log(e)&#125;function blue(str) &#123; return '\x1b[1m\x1b[34m' + str + '\x1b[39m\x1b[22m'&#125; 上面的代码的执行顺序就是 第一步首先调用config文件中的getAllBuilds函数，这个函数会返回一个数组，数组内是对象，对象包含构建不同版本的Vue.js的配置项第二步调用build函数，将getAllBuilds这个函数的返回值传入进去第三步在build函数内递归调用buildEntry函数，将配置项传入，注意:( 这时候配置项是单个的对象，不是数组了 )第四步在buildEntry中会调用rollup.rollup方法，这个方法会根据配置项去编译，编译后产生一个bundle，这个bundle在调用generate方法，把配置项传入，得到最后的Code，也就是编译后的代码，最终执行write方法，把Code写到js文件中第四步如果看不懂的话，下面这串代码可以看懂了12345678910111213141516171819rollup.rollup(config).then(function (bundle) &#123; return bundle.generate(output);&#125;).then(function (_ref) &#123; var code = _ref.code; if (isProd) &#123; var minified = (banner ? banner + '\n' : '') + uglify.minify(code, &#123; output: &#123; ascii_only: true &#125;, compress: &#123; pure_funcs: ['makeMap'] &#125; &#125;).code; return write(file, minified, true); &#125; else &#123; return write(file, code); &#125;&#125;); 这块属于构建工具的过程，就不继续详述了，如果想了解的话可以查看官方文档或者留言，我会抽时间出一个博客简单介绍一下 下一篇会介绍Vue到底是什么，是怎么初始化的.]]></content>
      <categories>
        <category>vue源码分析</category>
      </categories>
  </entry>
</search>
